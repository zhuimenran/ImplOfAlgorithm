#Kruskal
克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。

基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。 
具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，
并使森林中不产生回路，直至森林变成一棵树为止。

#example；
第1步：将边<E,F>加入R中。 
    边<E,F>的权值最小，因此将它加入到最小生成树结果R中。 
第2步：将边<C,D>加入R中。 
    上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果R中。 
第3步：将边<D,E>加入R中。 
    上一步操作之后，边<D,E>的权值最小，因此将它加入到最小生成树结果R中。 
第4步：将边<B,F>加入R中。 
    上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳过边<C,F>。将边<B,F>加入到最小生成树结果R中。 
第5步：将边<E,G>加入R中。 
    上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果R中。 
第6步：将边<A,B>加入R中。 
    上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳过边<B,C>。将边<A,B>加入到最小生成树结果R中。

此时，最小生成树构造完成！它包括的边依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。

##根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 
问题一 对图的所有边按照权值大小进行排序。 
问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。

问题一很好解决，采用排序算法进行排序即可。

问题二，处理方式是：记录顶点在"最小生成树"中的终点，
顶点的终点是"在最小生成树中与它连通的最大顶点"(关于这一点，
后面会通过图片给出说明)。然后每次需要将一条边添加到最小生存树
时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。
 以下图来进行说明：krukal03.jpg
 在将<E,F> <C,D> <D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：

(01) C的终点是F。 
(02) D的终点是F。 
(03) E的终点是F。 
(04) F的终点是F。

关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。 因此，接下来，虽然<C,E>是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。